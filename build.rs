// build.rs – emit `taxonomy.rs` and copy prompt templates

use phf_codegen::Map;
use std::fmt::Write;
use std::{env, fs, path::PathBuf};
use toml::Value;

type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;

fn main() -> Result<()> {
    println!("cargo:rerun-if-changed=assets/taxonomy.toml");
    println!("cargo:rerun-if-changed=assets/common_rules.txt");
    for i in 0..=5 {
        println!("cargo:rerun-if-changed=assets/prompt_L{i}.txt");
    }

    // Parse taxonomy definition
    let manifest_dir = env::var("CARGO_MANIFEST_DIR")?;
    let toml_path = PathBuf::from(&manifest_dir).join("assets/taxonomy.toml");
    let toml_str = fs::read_to_string(&toml_path)?;
    let doc = toml::from_str::<Value>(&toml_str)?;

    // Per-layer buffers (index 0 unused)
    let mut entries: Vec<Vec<(String, String)>> = vec![Vec::new(); 6];
    let mut whitelists: Vec<Vec<String>> = vec![Vec::new(); 6];

    if let Some(layers) = doc.get("layer").and_then(Value::as_table) {
        for (layer_name, data) in layers {
            let layer_idx: usize = layer_name
                .chars()
                .filter(char::is_ascii_digit)
                .collect::<String>()
                .parse()?;
            if !(1..=5).contains(&layer_idx) {
                return Err(format!("unexpected layer '{layer_name}'").into());
            }

            if let Some(tags) = data.get("tag").and_then(Value::as_table) {
                for (id, meta) in tags {
                    let g = |k| -> Result<&str> {
                        meta.get(k)
                            .and_then(Value::as_str)
                            .ok_or_else(|| format!("tag {id}: missing '{k}'").into())
                    };

                    let def_code = format!(
                        "TagDef {{ id: {id:?}, label: {l:?}, short_def: {s:?}, notes: {n:?} }}",
                        id = id,
                        l = g("label")?,
                        s = g("short_def")?,
                        n = g("notes")?
                    );

                    entries[layer_idx].push((id.clone(), def_code));
                    whitelists[layer_idx].push(id.clone());
                }
            }
        }
    }

    // ── Emit generated Rust ──────────────────────────────────────────────
    let mut out = String::new();
    out.push_str("// @generated by build.rs — DO NOT EDIT\n\n");

    // TagDef ----------------------------------------------------------------
    out.push_str(
        r#"#[derive(Copy, Clone)]
pub struct TagDef {
    pub id: &'static str,
    pub label: &'static str,
    pub short_def: &'static str,
    pub notes: &'static str,
}

"#,
    );

    // Layer enum ------------------------------------------------------------
    out.push_str(
        r#"#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum Layer { L1 = 1, L2, L3, L4, L5 }

"#,
    );

    // One PHF map per layer --------------------------------------------------
    for (layer_idx, layer_entries) in entries.iter().enumerate().skip(1).take(5) {
        let mut map = Map::new();
        for (id, def_code) in layer_entries {
            let leaked: &'static mut str = Box::leak(id.clone().into_boxed_str());
            map.entry(leaked as &'static str, def_code);
        }
        writeln!(
            out,
            "static L{layer}_MAP: phf::Map<&'static str, TagDef> = {};",
            map.build(),
            layer = layer_idx
        )?;
    }
    out.push('\n');

    // Array of map refs ------------------------------------------------------
    out.push_str(
        r#"static MAPS: [&'static phf::Map<&'static str, TagDef>; 6] = [
    &phf::Map::new(), // index 0 unused
"#,
    );
    for layer_idx in 1..=5 {
        writeln!(out, "    &L{layer}_MAP,", layer = layer_idx)?;
    }
    out.push_str("];\n\n");

    // Helpers ----------------------------------------------------------------
    out.push_str(
        r#"pub fn get_tagdef(layer: Layer, id: &str) -> Option<&'static TagDef> {
    MAPS[layer as usize].get(id)
}

pub fn all_tags(layer: Layer) -> &'static [&'static str] {
    TAGIDS[layer as usize]
}

"#,
    );

    // Parallel arrays of TagDef & ID slices ----------------------------------
    out.push_str("pub static TAGDEFS: [&'static [TagDef]; 6] = [\n    &[],\n");
    for layer_entries in entries.iter().skip(1) {
        out.push_str("    &[\n");
        for (_, def) in layer_entries {
            out.push_str(&format!("        {def},\n"));
        }
        out.push_str("    ],\n");
    }
    out.push_str("];\n\n");

    out.push_str(
        r#"pub fn tagdefs(layer: Layer) -> &'static [TagDef] {
    TAGDEFS[layer as usize]
}

"#,
    );

    out.push_str("pub static TAGIDS: [&'static [&'static str]; 6] = [\n    &[],\n");
    for list in whitelists.iter().skip(1) {
        out.push_str(&format!("    &{:?},\n", list));
    }
    out.push_str("];\n\n");

    out.push_str(
        r#"pub fn tag_ids(layer: Layer) -> &'static [&'static str] {
    TAGIDS[layer as usize]
}
"#,
    );

    // Persist generated file
    let out_dir = env::var("OUT_DIR")?;
    fs::write(PathBuf::from(&out_dir).join("taxonomy.rs"), out)?;

    // Copy prompt templates (expanding {{include …}})
    let common = fs::read_to_string(PathBuf::from(&manifest_dir).join("assets/common_rules.txt"))?;
    let prompts_out = PathBuf::from(&out_dir).join("prompts");
    fs::create_dir_all(&prompts_out)?;

    for layer in 0..=5 {
        let fname = format!("prompt_L{layer}.txt");
        let src = PathBuf::from(&manifest_dir).join("assets").join(&fname);
        let mut tpl = fs::read_to_string(&src)?;

        // splice {{include …}}
        tpl = tpl.replace("{{include common_rules.txt}}", &common);

        fs::write(prompts_out.join(&fname), tpl)?;
    }

    Ok(())
}
